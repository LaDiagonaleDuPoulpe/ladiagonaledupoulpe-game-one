{"version":3,"file":"app.js","sources":["webpack://[name]/webpack/universalModuleDefinition","webpack://[name]/webpack/bootstrap","webpack://[name]/./src/main.js","webpack://[name]/./src/prefabs/prefab.js","webpack://[name]/./src/prefabs/text-prefab.js","webpack://[name]/./src/scenes/boot-scene.js","webpack://[name]/./src/scenes/json-level-scene.js","webpack://[name]/./src/scenes/loading-scene.js","webpack://[name]/./src/scenes/title-scene.js","webpack://[name]/./src/scenes/world-scene.js"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"app\"] = factory();\n\telse\n\t\troot[\"app\"] = factory();\n})(window, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"./dev/\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n","import TitleScene from './scenes/title-scene';\nimport WordScene from './scenes/world-scene';\nimport BootScene from './scenes/boot-scene';\nimport LoadingScene from './scenes/loading-scene';\nvar TITLE_SCENE_KEY = 'TitleScene';\nvar BOOT_SCENE_KEY = 'BootScene';\nvar LOADING_SCENE_KEY = 'LoadingScene';\nvar WORLD_SCENE_KEY = 'WorldScene';\nvar titleScene = new TitleScene();\nvar bootScene = new BootScene();\nvar loadingScene = new LoadingScene();\nvar worldScene = new WordScene();\nvar config = {\n  type: Phaser.AUTO,\n  width: 640,\n  height: 640\n};\nvar game = new Phaser.Game(config);\ngame.scene.add(TITLE_SCENE_KEY, titleScene);\ngame.scene.add(WORLD_SCENE_KEY, worldScene);\ngame.scene.add(BOOT_SCENE_KEY, bootScene);\ngame.scene.add(LOADING_SCENE_KEY, loadingScene);\ngame.scene.start(BOOT_SCENE_KEY, {\n  scene: 'title'\n});","function _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nvar Prefab =\n/*#__PURE__*/\nfunction (_Phaser$GameObjects$S) {\n  _inherits(Prefab, _Phaser$GameObjects$S);\n\n  function Prefab(scene, name, position, properties) {\n    var _this;\n\n    _classCallCheck(this, Prefab);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(Prefab).call(this, scene, position.x, position.y, properties.texture, properties.frame));\n    _this.scene = scene;\n    _this.name = name;\n\n    _this.scene.add.existing(_assertThisInitialized(_this));\n\n    _this.scene.groups[properties.group].add(_assertThisInitialized(_this));\n\n    if (properties.scale) {\n      _this.setScale(properties.scale.x, properties.scale.y);\n    }\n\n    if (properties.anchor) {\n      _this.setOrigin(properties.anchor.x, properties.anchor.y);\n    }\n\n    _this.scene.prefabs[_this.name] = _assertThisInitialized(_this);\n    return _this;\n  }\n\n  return Prefab;\n}(Phaser.GameObjects.Sprite);\n\nexport default Prefab;","function _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nvar TextPrefab =\n/*#__PURE__*/\nfunction (_Phaser$GameObjects$T) {\n  _inherits(TextPrefab, _Phaser$GameObjects$T);\n\n  function TextPrefab(scene, name, position, properties) {\n    var _this;\n\n    _classCallCheck(this, TextPrefab);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(TextPrefab).call(this, scene, position.x, position.y, properties.text, properties.style)); // TODO: doing better => prefab and text-prefab got the same code in constructor\n\n    _this.scene = scene;\n    _this.name = name;\n\n    _this.scene.add.existing(_assertThisInitialized(_this));\n\n    _this.scene.groups[properties.group].add(_assertThisInitialized(_this));\n\n    if (properties.scale) {\n      _this.setScale(properties.scale.x, properties.scale.y);\n    }\n\n    if (properties.anchor) {\n      _this.setOrigin(properties.anchor.x, properties.anchor.y);\n    }\n\n    _this.scene.prefabs[_this.name] = _assertThisInitialized(_this);\n    return _this;\n  }\n\n  return TextPrefab;\n}(Phaser.GameObjects.Text);\n\nexport default TextPrefab;","function _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\n/**\r\n * Scene that loads the game\r\n * After, it will load the loading scene\r\n */\nvar BootScene =\n/*#__PURE__*/\nfunction (_Phaser$Scene) {\n  _inherits(BootScene, _Phaser$Scene);\n\n  function BootScene() {\n    var _this;\n\n    _classCallCheck(this, BootScene);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(BootScene).call(this, {\n      key: 'BootScene'\n    }));\n    _this.levels = {\n      title: {\n        key: 'TitleScene',\n        path: 'assets/levels/title_screen.json'\n      },\n      town: {\n        key: 'WorldScene',\n        path: 'assets/levels/town.json'\n      }\n    };\n    return _this;\n  }\n\n  _createClass(BootScene, [{\n    key: \"preload\",\n    value: function preload() {\n      for (var name in this.levels) {\n        var level = this.levels[name];\n        this.load.json(name, level.path);\n      }\n    }\n  }, {\n    key: \"create\",\n    value: function create(data) {\n      var levelData = this.cache.json.get(data.scene);\n      this.scene.start('LoadingScene', {\n        levelData: levelData,\n        scene: this.levels[data.scene].key\n      });\n    }\n  }]);\n\n  return BootScene;\n}(Phaser.Scene);\n\nexport default BootScene;","function _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nimport Prefab from '../prefabs/prefab';\nimport TextPrefab from '../prefabs/text-prefab';\n/**\r\n * Parent class to all scenev: anable you to load data from json file\r\n */\n\nvar JSonLevelScene =\n/*#__PURE__*/\nfunction (_Phaser$Scene) {\n  _inherits(JSonLevelScene, _Phaser$Scene);\n\n  function JSonLevelScene(key) {\n    var _this;\n\n    _classCallCheck(this, JSonLevelScene);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(JSonLevelScene).call(this, {\n      key: key\n    }));\n\n    _this.setPrefabs();\n\n    return _this;\n  }\n\n  _createClass(JSonLevelScene, [{\n    key: \"init\",\n    value: function init(data) {\n      this.levelData = data.levelData;\n    }\n  }, {\n    key: \"create\",\n    value: function create() {\n      var _this2 = this;\n\n      this.prefabs = {};\n      this.groups = {};\n      this.levelData.groups.forEach(function (name) {\n        _this2.groups[name] = _this2.add.group();\n      }, this);\n\n      for (var key in this.levelData.prefabs) {\n        var spriteData = this.levelData.prefabs[key];\n        var prefab = new this.prefabsClasses[spriteData.type](this, key, spriteData.position, spriteData.properties);\n      }\n    }\n    /**\r\n     * Define prefabs list \r\n     * You must with constructors\r\n     * Todo: doing better : just pass class type, and the parent class will set all constructors in the array list\r\n     */\n\n  }, {\n    key: \"setPrefabs\",\n    value: function setPrefabs() {\n      throw new Error('You must override it in child class');\n    }\n  }]);\n\n  return JSonLevelScene;\n}(Phaser.Scene);\n\nexport default JSonLevelScene;","function _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nvar LoadingScene =\n/*#__PURE__*/\nfunction (_Phaser$Scene) {\n  _inherits(LoadingScene, _Phaser$Scene);\n\n  function LoadingScene() {\n    _classCallCheck(this, LoadingScene);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(LoadingScene).call(this, {\n      key: 'LoadingScene'\n    }));\n  }\n\n  _createClass(LoadingScene, [{\n    key: \"init\",\n    value: function init(data) {\n      this.levelData = data.levelData;\n      var message = this.add.text(320, 240, \"Loading\", {\n        font: \"48px Kells\",\n        fill: \"#ffffff\"\n      });\n    }\n  }, {\n    key: \"preload\",\n    value: function preload() {\n      var assets = this.levelData.assets;\n\n      for (var key in assets) {\n        var asset = assets[key];\n\n        switch (asset.type) {\n          case 'image':\n            this.load.image(key, asset.source);\n            break;\n\n          case 'spritesheet':\n            {\n              this.load.spritesheet(key, asset.source, {\n                frameWidth: asset.frameWidth,\n                frameHeight: asset.frameHeight,\n                frames: asset.frames,\n                margin: asset.margin,\n                spacing: asset.spacing\n              });\n            }\n            break;\n\n          case \"tilemap\":\n            {\n              this.load.tilemapTiledJSON(key, asset.source);\n            }\n            break;\n\n          default:\n            break;\n        }\n      }\n    }\n  }, {\n    key: \"create\",\n    value: function create(data) {\n      this.scene.start(data.scene, {\n        levelData: this.levelData\n      });\n    }\n  }]);\n\n  return LoadingScene;\n}(Phaser.Scene);\n\nexport default LoadingScene;","function _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nimport JSonLevelScene from './json-level-scene';\nimport Prefab from '../prefabs/prefab';\nimport TextPrefab from '../prefabs/text-prefab';\n/**\r\n * Scene displaying title and starts game after clicked on it\r\n */\n\nvar TitleScene =\n/*#__PURE__*/\nfunction (_JSonLevelScene) {\n  _inherits(TitleScene, _JSonLevelScene);\n\n  function TitleScene() {\n    _classCallCheck(this, TitleScene);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(TitleScene).call(this, 'TitleScene'));\n  } //#region public methods\n\n\n  _createClass(TitleScene, [{\n    key: \"update\",\n    value: function update() {\n      if (this.input.activePointer.isDown) {\n        this.startGame();\n      }\n    } //#endregion\n    //#region internal methods\n\n  }, {\n    key: \"startGame\",\n    value: function startGame() {\n      console.log('starting');\n      this.scene.start('BootScene', {\n        scene: 'town'\n      });\n    }\n  }, {\n    key: \"setPrefabs\",\n    value: function setPrefabs() {\n      console.log('setPrefabs');\n      this.prefabsClasses = {\n        background: Prefab.prototype.constructor,\n        text: TextPrefab.prototype.constructor\n      };\n    } //#endregion\n\n  }]);\n\n  return TitleScene;\n}(JSonLevelScene);\n\nexport default TitleScene;","function _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _get(target, property, receiver) { if (typeof Reflect !== \"undefined\" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }\n\nfunction _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nimport JSonLevelScene from './json-level-scene';\nimport Prefab from '../prefabs/prefab';\nimport TextPrefab from '../prefabs/text-prefab';\n/**\r\n* Loading worl tilemap scene\r\n*/\n\nvar WorldScene =\n/*#__PURE__*/\nfunction (_JSonLevelScene) {\n  _inherits(WorldScene, _JSonLevelScene);\n\n  function WorldScene() {\n    _classCallCheck(this, WorldScene);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(WorldScene).call(this, 'WorldScene'));\n  } //#region public methods\n\n\n  _createClass(WorldScene, [{\n    key: \"create\",\n    value: function create() {\n      this.map = this.add.tilemap(this.levelData.map.key);\n      this.prepareTileSets();\n      this.prepareLayers();\n\n      _get(_getPrototypeOf(WorldScene.prototype), \"create\", this).call(this);\n\n      this.prepareObjects();\n    } //#endregion\n    //#region internal methods\n\n  }, {\n    key: \"prepareObjects\",\n    value: function prepareObjects() {\n      var _this = this;\n\n      this.map.objects.forEach(function (layer) {\n        layer.objects.forEach(_this.createOneOject, _this);\n      });\n    }\n  }, {\n    key: \"createOneOject\",\n    value: function createOneOject(object) {\n      var position = {\n        x: object.x + object.width / 2,\n        y: object.y + object.height / 2\n      };\n\n      if (this.prefabsClasses.hasOwnProperty(object.type)) {\n        var prefab = new this.prefabsClasses[object.type](this, object.name, position, object.properties);\n      }\n    }\n  }, {\n    key: \"prepareLayers\",\n    value: function prepareLayers() {\n      var _this2 = this;\n\n      this.layers = {};\n      this.map.layers.forEach(function (layer, index) {\n        _this2.layers[layer.name] = _this2.map.createStaticLayer(layer.name, _this2.tilesets[layer.properties.tileset]);\n\n        if (layer.properties.collision) {\n          _this2.map.setCollisionByExclusion([-1], true, layer.name);\n        }\n      });\n    }\n  }, {\n    key: \"prepareTileSets\",\n    value: function prepareTileSets() {\n      var _this3 = this;\n\n      this.tilesets = {};\n      this.map.tilesets.forEach(function (tileSet, index) {\n        var tileSetContent = _this3.levelData.map.tilesets[index];\n\n        var mapTileset = _this3.map.addTilesetImage(tileSet.name, tileSetContent);\n\n        _this3.tilesets[tileSetContent] = mapTileset;\n      }, this);\n    }\n  }, {\n    key: \"setPrefabs\",\n    value: function setPrefabs() {\n      this.prefabsClasses = {\n        player: Prefab.prototype.constructor\n      };\n    } //#endregion\n\n  }]);\n\n  return WorldScene;\n}(JSonLevelScene);\n\nexport default WorldScene;"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AClFA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACxBA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC/CA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AChDA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACtEA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AChFA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACxFA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACrEA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;A","sourceRoot":""}