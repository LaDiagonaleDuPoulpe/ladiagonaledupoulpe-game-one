{"version":3,"file":"app.js","sources":["webpack://[name]/webpack/universalModuleDefinition","webpack://[name]/webpack/bootstrap","webpack://[name]/./src/main.js","webpack://[name]/./src/plugins/user-input.js","webpack://[name]/./src/prefabs/prefab.js","webpack://[name]/./src/prefabs/text-prefab.js","webpack://[name]/./src/prefabs/world/door.js","webpack://[name]/./src/prefabs/world/npc.js","webpack://[name]/./src/prefabs/world/player.js","webpack://[name]/./src/scenes/boot-scene.js","webpack://[name]/./src/scenes/json-level-scene.js","webpack://[name]/./src/scenes/loading-scene.js","webpack://[name]/./src/scenes/title-scene.js","webpack://[name]/./src/scenes/world-scene.js"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"app\"] = factory();\n\telse\n\t\troot[\"app\"] = factory();\n})(window, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"./dev/\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n","import TitleScene from './scenes/title-scene';\nimport WordScene from './scenes/world-scene';\nimport BootScene from './scenes/boot-scene';\nimport LoadingScene from './scenes/loading-scene';\nvar TITLE_SCENE_KEY = 'TitleScene';\nvar BOOT_SCENE_KEY = 'BootScene';\nvar LOADING_SCENE_KEY = 'LoadingScene';\nvar WORLD_SCENE_KEY = 'WorldScene';\nvar titleScene = new TitleScene();\nvar bootScene = new BootScene();\nvar loadingScene = new LoadingScene();\nvar worldScene = new WordScene();\nvar config = {\n  type: Phaser.AUTO,\n  width: 640,\n  height: 640,\n  physics: {\n    \"default\": 'arcade',\n    arcade: {\n      gravity: {\n        y: 0\n      }\n    }\n  }\n};\nvar game = new Phaser.Game(config);\ngame.scene.add(TITLE_SCENE_KEY, titleScene);\ngame.scene.add(WORLD_SCENE_KEY, worldScene);\ngame.scene.add(BOOT_SCENE_KEY, bootScene);\ngame.scene.add(LOADING_SCENE_KEY, loadingScene);\ngame.scene.start(BOOT_SCENE_KEY, {\n  scene: 'title'\n});","function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nvar UserInput =\n/*#__PURE__*/\nfunction () {\n  function UserInput(scene) {\n    _classCallCheck(this, UserInput);\n\n    this.scene = scene;\n    this.enabled = false;\n    this.keyListeners = ['down', 'up'];\n  } //#region public methods\n\n  /**\r\n   * attach on input press key\r\n   * @param {*} data json data\r\n   */\n\n\n  _createClass(UserInput, [{\n    key: \"setInput\",\n    value: function setInput(data) {\n      var _this = this;\n\n      this.keyListeners.forEach(function (item) {\n        var key = 'key' + item;\n\n        _this.scene.input.keyboard.removeAllListeners(key);\n\n        _this.scene.input.keyboard.on(key, _this.processInput, _this);\n      });\n      this.userData = data;\n      this.enabled = true;\n    } //#endregion\n    //#region internal methods\n\n    /**\r\n     * Keyboard event process\r\n     * @param {*} event key event\r\n     */\n\n  }, {\n    key: \"processInput\",\n    value: function processInput(event) {\n      if (this.enabled) {\n        var input = this.userData[event.type][event.key];\n\n        if (input) {\n          var callbackArray = input.callback.split('.');\n          var context = this.getContext(callbackArray);\n          var callingMethod = this.getCallingMethod(context, callbackArray);\n          callingMethod.apply(context, input.args);\n        }\n      }\n    }\n    /**\r\n     * Gets calling method from json file and event key\r\n     * @param {*} context \r\n     * @param {string[]} callbackArray \r\n     */\n\n  }, {\n    key: \"getCallingMethod\",\n    value: function getCallingMethod(context, callbackArray) {\n      var methodName = callbackArray[1];\n      return context[methodName];\n    }\n    /**\r\n     * Gets callback array, with context name and callback method\r\n     * @param {string[]} callbackArray \r\n     */\n\n  }, {\n    key: \"getContext\",\n    value: function getContext(callbackArray) {\n      var context = undefined;\n      var callingObject = callbackArray[0];\n\n      if (callingObject === 'scene') {\n        context = this.scene;\n      } else {\n        context = this.scene.prefabs[callingObject];\n      }\n\n      return context;\n    } //#endregion\n\n  }]);\n\n  return UserInput;\n}();\n\nexport default UserInput;","function _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nvar Prefab =\n/*#__PURE__*/\nfunction (_Phaser$GameObjects$S) {\n  _inherits(Prefab, _Phaser$GameObjects$S);\n\n  function Prefab(scene, name, position, properties) {\n    var _this;\n\n    _classCallCheck(this, Prefab);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(Prefab).call(this, scene, position.x, position.y, properties.texture, properties.frame));\n\n    _this.initialize(scene, name, position, properties);\n\n    return _this;\n  } //#region protected methods\n\n\n  _createClass(Prefab, [{\n    key: \"initialize\",\n    value: function initialize(scene, name, position, properties) {\n      this.scene = scene;\n      this.name = name;\n      this.scene.add.existing(this);\n      this.scene.groups[properties.group].add(this);\n\n      if (properties.scale) {\n        this.setScale(properties.scale.x, properties.scale.y);\n      }\n\n      if (properties.anchor) {\n        this.setOrigin(properties.anchor.x, properties.anchor.y);\n      }\n\n      this.scene.prefabs[this.name] = this;\n    } //#endregion\n\n  }]);\n\n  return Prefab;\n}(Phaser.GameObjects.Sprite);\n\nexport default Prefab;","function _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nvar TextPrefab =\n/*#__PURE__*/\nfunction (_Phaser$GameObjects$T) {\n  _inherits(TextPrefab, _Phaser$GameObjects$T);\n\n  function TextPrefab(scene, name, position, properties) {\n    var _this;\n\n    _classCallCheck(this, TextPrefab);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(TextPrefab).call(this, scene, position.x, position.y, properties.text, properties.style)); // TODO: doing better => prefab and text-prefab got the same code in constructor\n\n    _this.scene = scene;\n    _this.name = name;\n\n    _this.scene.add.existing(_assertThisInitialized(_this));\n\n    _this.scene.groups[properties.group].add(_assertThisInitialized(_this));\n\n    if (properties.scale) {\n      _this.setScale(properties.scale.x, properties.scale.y);\n    }\n\n    if (properties.anchor) {\n      _this.setOrigin(properties.anchor.x, properties.anchor.y);\n    }\n\n    _this.scene.prefabs[_this.name] = _assertThisInitialized(_this);\n    return _this;\n  }\n\n  return TextPrefab;\n}(Phaser.GameObjects.Text);\n\nexport default TextPrefab;","function _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _get(target, property, receiver) { if (typeof Reflect !== \"undefined\" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }\n\nfunction _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nimport Prefab from '../prefab';\nimport TitleScene from '../../scenes/title-scene';\n\nvar Door =\n/*#__PURE__*/\nfunction (_Prefab) {\n  _inherits(Door, _Prefab);\n\n  function Door(scene, name, position, properties) {\n    _classCallCheck(this, Door);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(Door).call(this, scene, name, position, properties));\n  } //#region public methods    \n  //#endregion\n  //#region protected methods\n\n\n  _createClass(Door, [{\n    key: \"initialize\",\n    value: function initialize(scene, name, position, properties) {\n      _get(_getPrototypeOf(Door.prototype), \"initialize\", this).call(this, scene, name, position, properties);\n\n      this.nextLevel = properties.nextLevel;\n      this.scene.physics.add.collider(this, this.scene.groups.players, this.enter, null, this);\n      this.body.immovable = true;\n    }\n    /**\r\n    * Actions when user enters in the cave\r\n    * (callback when collision with Door)\r\n    */\n\n  }, {\n    key: \"enter\",\n    value: function enter() {\n      this.scene.scene.start('BootScene', {\n        scene: this.nextLevel\n      });\n    } //#endregion\n\n  }]);\n\n  return Door;\n}(Prefab);\n\nexport default Door;","function _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _get(target, property, receiver) { if (typeof Reflect !== \"undefined\" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }\n\nfunction _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nimport Prefab from '../prefab';\nimport TitleScene from '../../scenes/title-scene';\n\nvar NPC =\n/*#__PURE__*/\nfunction (_Prefab) {\n  _inherits(NPC, _Prefab);\n\n  function NPC(scene, name, position, properties) {\n    _classCallCheck(this, NPC);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(NPC).call(this, scene, name, position, properties));\n  } //#region public methods    \n  //#endregion\n  //#region protected methods\n\n\n  _createClass(NPC, [{\n    key: \"initialize\",\n    value: function initialize(scene, name, position, properties) {\n      _get(_getPrototypeOf(NPC.prototype), \"initialize\", this).call(this, scene, name, position, properties);\n\n      this.message = this.scene.cache.text.get(properties.message);\n      this.scene.physics.add.collider(this, this.scene.groups.players, this.talk, null, this);\n      this.body.immovable = true;\n    }\n    /**\r\n    * Actions when people will talk\r\n    * (displaying npc message)\r\n    */\n\n  }, {\n    key: \"talk\",\n    value: function talk(npc, player) {\n      player.stop();\n      console.log('talk', this.message);\n    } //#endregion\n\n  }]);\n\n  return NPC;\n}(Prefab);\n\nexport default NPC;","function _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _get(target, property, receiver) { if (typeof Reflect !== \"undefined\" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }\n\nfunction _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nimport Prefab from '../prefab';\nimport TitleScene from '../../scenes/title-scene';\n\nvar Player =\n/*#__PURE__*/\nfunction (_Prefab) {\n  _inherits(Player, _Prefab);\n\n  function Player(scene, name, position, properties) {\n    _classCallCheck(this, Player);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(Player).call(this, scene, name, position, properties));\n  } //#region public methods\n\n\n  _createClass(Player, [{\n    key: \"update\",\n    value: function update() {\n      if (this.body) {\n        this.moveByKeyDown();\n      }\n    }\n    /**\r\n     * Activates direction of the player\r\n     * @param {string} direction \r\n     * @param {boolean} isMoving \r\n     */\n\n  }, {\n    key: \"changeMovement\",\n    value: function changeMovement(direction, isMoving) {\n      this.movingDirections[direction] = isMoving;\n    }\n    /**\r\n     * Stops movement of the player\r\n     */\n\n  }, {\n    key: \"stop\",\n    value: function stop() {\n      this.stoppingMovements();\n    } //#endregion\n    //#region protected methods\n\n  }, {\n    key: \"initialize\",\n    value: function initialize(scene, name, position, properties) {\n      _get(_getPrototypeOf(Player.prototype), \"initialize\", this).call(this, scene, name, position, properties);\n\n      this.defineCollisionSettings();\n      this.defineWalkingSpeed(properties);\n      this.attachPlayerMovments();\n      this.prepareAnimationsByMovment();\n    } //#endregion\n    //#region internal methods\n\n  }, {\n    key: \"stoppingMovements\",\n    value: function stoppingMovements() {\n      this.movingDirections.down = false;\n      this.movingDirections.left = false;\n      this.movingDirections.right = false;\n      this.movingDirections.up = false;\n    }\n  }, {\n    key: \"moveByKeyDown\",\n    value: function moveByKeyDown() {\n      // console.log('moveByKeyDown->velocity.x', this.body.velocity.x);\n      // console.log('moveByKeyDown->velocity.y', this.body.velocity.y);\n      this.moveHorizontal();\n      this.moveVertical();\n      this.stopCurrentAnimation();\n    }\n  }, {\n    key: \"moveVertical\",\n    value: function moveVertical() {\n      if (this.movingDirections.up && this.body.velocity.y <= 0) {\n        this.body.velocity.y = -this.walkingSpeed;\n\n        if (this.body.velocity.x === 0) {\n          this.anims.play('walking_up', true);\n        }\n      } else if (this.movingDirections.down && this.body.velocity.y >= 0) {\n        this.body.velocity.y = this.walkingSpeed;\n\n        if (this.body.velocity.x === 0) {\n          this.anims.play('walking_down', true);\n        }\n      } else {\n        this.body.velocity.y = 0;\n      }\n    }\n  }, {\n    key: \"moveHorizontal\",\n    value: function moveHorizontal() {\n      if (this.movingDirections.left && this.body.velocity.x <= 0) {\n        this.body.velocity.x = -this.walkingSpeed;\n\n        if (this.body.velocity.y === 0) {\n          this.anims.play('walking_left', true);\n        }\n      } else if (this.movingDirections.right && this.body.velocity.x >= 0) {\n        this.body.velocity.x = this.walkingSpeed;\n\n        if (this.body.velocity.y === 0) {\n          this.anims.play('walking_right', true);\n        }\n      } else {\n        this.body.velocity.x = 0;\n      }\n    }\n  }, {\n    key: \"stopCurrentAnimation\",\n    value: function stopCurrentAnimation() {\n      if (this.body.velocity.x === 0 && this.body.velocity.y === 0) {\n        this.anims.stop();\n        this.displayCurrentFrameFromDirection();\n      }\n    }\n  }, {\n    key: \"displayCurrentFrameFromDirection\",\n    value: function displayCurrentFrameFromDirection() {\n      // console.log('displayCurrentFrameFromDirection->this.body.facing - 10 :', this.body.facing - 10);\n      this.setFrame(this.stoppedAnimationFrames[this.body.facing - 10]);\n    }\n  }, {\n    key: \"attachPlayerMovments\",\n    value: function attachPlayerMovments() {\n      this.movingDirections = {\n        left: false,\n        right: false,\n        up: false,\n        down: false\n      };\n    }\n  }, {\n    key: \"prepareAnimationsByMovment\",\n    value: function prepareAnimationsByMovment() {\n      this.prepareOneAnimationByMovment('down', 0);\n      this.prepareOneAnimationByMovment('up', 1);\n      this.prepareOneAnimationByMovment('left', 2);\n      this.prepareOneAnimationByMovment('right', 3);\n      this.stoppedAnimationFrames = [0, 1, 0, 2, 3];\n    }\n  }, {\n    key: \"prepareOneAnimationByMovment\",\n    value: function prepareOneAnimationByMovment(direction) {\n      var spriteLevel = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      var directionKey = \"walking_\".concat(direction);\n\n      if (!this.scene.anims.anims.has(directionKey)) {\n        this.scene.anims.create({\n          key: directionKey,\n          frames: this.scene.anims.generateFrameNumbers(this.texture.key, {\n            frames: [0 + spriteLevel, 4 + spriteLevel, 8 + spriteLevel, 12 + spriteLevel]\n          }),\n          frameRate: 6,\n          repeat: -1\n        });\n      }\n    }\n  }, {\n    key: \"defineWalkingSpeed\",\n    value: function defineWalkingSpeed(properties) {\n      this.walkingSpeed = +properties.walkingSpeed;\n    }\n  }, {\n    key: \"defineCollisionSettings\",\n    value: function defineCollisionSettings() {\n      this.body.collideWorldBounds = true;\n      this.scene.physics.add.collider(this, this.scene.layers.buildings);\n    } //#endregion\n\n  }]);\n\n  return Player;\n}(Prefab);\n\nexport default Player;","function _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\n/**\r\n * Scene that loads the game\r\n * After, it will load the loading scene\r\n */\nvar BootScene =\n/*#__PURE__*/\nfunction (_Phaser$Scene) {\n  _inherits(BootScene, _Phaser$Scene);\n\n  function BootScene() {\n    var _this;\n\n    _classCallCheck(this, BootScene);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(BootScene).call(this, {\n      key: 'BootScene'\n    }));\n    _this.levels = {\n      title: {\n        key: 'TitleScene',\n        path: 'assets/levels/title_screen.json'\n      },\n      town: {\n        key: 'WorldScene',\n        path: 'assets/levels/town.json'\n      },\n      cave: {\n        key: 'WorldScene',\n        path: 'assets/levels/cave.json'\n      }\n    };\n    return _this;\n  }\n\n  _createClass(BootScene, [{\n    key: \"preload\",\n    value: function preload() {\n      for (var name in this.levels) {\n        var level = this.levels[name];\n        this.load.json(name, level.path);\n      }\n    }\n  }, {\n    key: \"create\",\n    value: function create(data) {\n      var levelData = this.cache.json.get(data.scene);\n      this.scene.start('LoadingScene', {\n        levelData: levelData,\n        scene: this.levels[data.scene].key\n      });\n    }\n  }]);\n\n  return BootScene;\n}(Phaser.Scene);\n\nexport default BootScene;","function _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nimport Prefab from '../prefabs/prefab';\nimport TextPrefab from '../prefabs/text-prefab';\nimport UserInput from '../plugins/user-input';\n/**\r\n* Parent class to all scenev: anable you to load data from json file\r\n*/\n\nvar JSonLevelScene =\n/*#__PURE__*/\nfunction (_Phaser$Scene) {\n  _inherits(JSonLevelScene, _Phaser$Scene);\n\n  function JSonLevelScene(key) {\n    var _this;\n\n    _classCallCheck(this, JSonLevelScene);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(JSonLevelScene).call(this, {\n      key: key\n    }));\n\n    _this.setPrefabs();\n\n    return _this;\n  } //#region public methods\n\n\n  _createClass(JSonLevelScene, [{\n    key: \"init\",\n    value: function init(data) {\n      this.levelData = data.levelData;\n    }\n  }, {\n    key: \"create\",\n    value: function create() {\n      this.prefabs = {};\n      this.groups = {};\n      this.createGroups();\n      this.initAllPrefabs();\n      this.initUserInputPlugin();\n    }\n  }, {\n    key: \"update\",\n    value: function update() {\n      this.updateAllPrefabs();\n    } //#endregion\n    //#region internal methods\n\n    /**\r\n     * Inits new UserInput class\r\n     */\n\n  }, {\n    key: \"initUserInputPlugin\",\n    value: function initUserInputPlugin() {\n      this.userInput = new UserInput(this);\n      this.userInputData = this.cache.json.get(this.levelData.userInput.key);\n      this.userInput.setInput(this.userInputData);\n    }\n    /**\r\n     * Updates all child prefabs\r\n     */\n\n  }, {\n    key: \"updateAllPrefabs\",\n    value: function updateAllPrefabs() {\n      for (var name in this.prefabs) {\n        if (this.prefabs.hasOwnProperty(name)) {\n          this.prefabs[name].update();\n        }\n      }\n    }\n    /**\r\n     * Creates physic group (to manage collision for example)\r\n     */\n\n  }, {\n    key: \"createGroups\",\n    value: function createGroups() {\n      var _this2 = this;\n\n      this.levelData.groups.forEach(function (name) {\n        _this2.groups[name] = _this2.physics.add.group();\n      }, this);\n    }\n    /**\r\n     * Create all prefab items\r\n     */\n\n  }, {\n    key: \"initAllPrefabs\",\n    value: function initAllPrefabs() {\n      for (var key in this.levelData.prefabs) {\n        var spriteData = this.levelData.prefabs[key];\n        var prefab = new this.prefabsClasses[spriteData.type](this, key, spriteData.position, spriteData.properties);\n      }\n    }\n    /**\r\n    * Define prefabs list \r\n    * You must with constructors\r\n    * Todo: doing better : just pass class type, and the parent class will set all constructors in the array list\r\n    */\n\n  }, {\n    key: \"setPrefabs\",\n    value: function setPrefabs() {\n      throw new Error('You must override it in child class');\n    } //#endregion\n\n  }]);\n\n  return JSonLevelScene;\n}(Phaser.Scene);\n\nexport default JSonLevelScene;","function _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nvar LoadingScene =\n/*#__PURE__*/\nfunction (_Phaser$Scene) {\n  _inherits(LoadingScene, _Phaser$Scene);\n\n  function LoadingScene() {\n    _classCallCheck(this, LoadingScene);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(LoadingScene).call(this, {\n      key: 'LoadingScene'\n    }));\n  } //#region public methods\n\n\n  _createClass(LoadingScene, [{\n    key: \"init\",\n    value: function init(data) {\n      this.levelData = data.levelData;\n      var message = this.add.text(320, 240, \"Loading\", {\n        font: \"48px Kells\",\n        fill: \"#ffffff\"\n      });\n    }\n  }, {\n    key: \"preload\",\n    value: function preload() {\n      var assets = this.levelData.assets;\n      this.loadAssetsByType(assets);\n      this.loadUserInputData();\n    }\n  }, {\n    key: \"create\",\n    value: function create(data) {\n      this.scene.start(data.scene, {\n        levelData: this.levelData\n      });\n    } //#endregion\n    //#region internal methods\n\n    /**\r\n     * Loads image, spritesheets or tilemap from json data\r\n     * @param {*} assets \r\n     */\n\n  }, {\n    key: \"loadAssetsByType\",\n    value: function loadAssetsByType(assets) {\n      for (var key in assets) {\n        var asset = assets[key];\n\n        switch (asset.type) {\n          case 'image':\n            this.load.image(key, asset.source);\n            break;\n\n          case 'spritesheet':\n            {\n              this.load.spritesheet(key, asset.source, {\n                frameWidth: asset.frameWidth,\n                frameHeight: asset.frameHeight,\n                frames: asset.frames,\n                margin: asset.margin,\n                spacing: asset.spacing\n              });\n            }\n            break;\n\n          case \"tilemap\":\n            {\n              this.load.tilemapTiledJSON(key, asset.source);\n            }\n            break;\n\n          default:\n            break;\n        }\n      }\n    }\n    /**\r\n     * Loads user input json file\r\n     */\n\n  }, {\n    key: \"loadUserInputData\",\n    value: function loadUserInputData() {\n      this.load.json(this.levelData.userInput.key, this.levelData.userInput.path);\n    } //#endregion\n\n  }]);\n\n  return LoadingScene;\n}(Phaser.Scene);\n\nexport default LoadingScene;","function _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nimport JSonLevelScene from './json-level-scene';\nimport Prefab from '../prefabs/prefab';\nimport TextPrefab from '../prefabs/text-prefab';\n/**\r\n * Scene displaying title and starts game after clicked on it\r\n */\n\nvar TitleScene =\n/*#__PURE__*/\nfunction (_JSonLevelScene) {\n  _inherits(TitleScene, _JSonLevelScene);\n\n  function TitleScene() {\n    _classCallCheck(this, TitleScene);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(TitleScene).call(this, 'TitleScene'));\n  } //#region public methods\n  //#endregion\n  //#region internal methods\n\n\n  _createClass(TitleScene, [{\n    key: \"startGame\",\n    value: function startGame() {\n      console.log('starting');\n      this.scene.start('BootScene', {\n        scene: 'town'\n      });\n    }\n  }, {\n    key: \"setPrefabs\",\n    value: function setPrefabs() {\n      console.log('setPrefabs');\n      this.prefabsClasses = {\n        background: Prefab.prototype.constructor,\n        text: TextPrefab.prototype.constructor\n      };\n    } //#endregion\n\n  }]);\n\n  return TitleScene;\n}(JSonLevelScene);\n\nexport default TitleScene;","function _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _get(target, property, receiver) { if (typeof Reflect !== \"undefined\" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }\n\nfunction _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nimport JSonLevelScene from './json-level-scene';\nimport Prefab from '../prefabs/prefab';\nimport TextPrefab from '../prefabs/text-prefab';\nimport Player from '../prefabs/world/player';\nimport Door from '../prefabs/world/door';\nimport NPC from '../prefabs/world/npc';\n/**\r\n* Loading world tilemap scene\r\n*/\n\nvar WorldScene =\n/*#__PURE__*/\nfunction (_JSonLevelScene) {\n  _inherits(WorldScene, _JSonLevelScene);\n\n  function WorldScene() {\n    _classCallCheck(this, WorldScene);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(WorldScene).call(this, 'WorldScene'));\n  } //#region public methods\n\n\n  _createClass(WorldScene, [{\n    key: \"create\",\n    value: function create() {\n      this.map = this.add.tilemap(this.levelData.map.key);\n      this.prepareTileSets();\n      this.prepareLayers();\n\n      _get(_getPrototypeOf(WorldScene.prototype), \"create\", this).call(this);\n\n      this.prepareObjects();\n    }\n  }, {\n    key: \"preload\",\n    value: function preload() {\n      this.loadMessages();\n    } //#endregion\n    //#region internal methods\n\n  }, {\n    key: \"loadMessages\",\n    value: function loadMessages() {\n      for (var key in this.levelData.npcMessages) {\n        this.load.text(key, this.levelData.npcMessages[key]);\n      }\n    }\n  }, {\n    key: \"prepareObjects\",\n    value: function prepareObjects() {\n      var _this = this;\n\n      this.map.objects.forEach(function (layer) {\n        layer.objects.forEach(_this.createOneOject, _this);\n      });\n    }\n  }, {\n    key: \"createOneOject\",\n    value: function createOneOject(object) {\n      var position = {\n        x: object.x + object.width / 2,\n        y: object.y + object.height / 2\n      };\n\n      if (this.prefabsClasses.hasOwnProperty(object.type)) {\n        var prefab = new this.prefabsClasses[object.type](this, object.name, position, object.properties);\n      }\n    }\n  }, {\n    key: \"prepareLayers\",\n    value: function prepareLayers() {\n      var _this2 = this;\n\n      this.layers = {};\n      this.map.layers.forEach(function (layer, index) {\n        _this2.layers[layer.name] = _this2.map.createStaticLayer(layer.name, _this2.tilesets[layer.properties.tileset]);\n\n        if (layer.properties.collision) {\n          _this2.map.setCollisionByExclusion([-1], true, layer.name);\n        }\n      });\n    }\n  }, {\n    key: \"prepareTileSets\",\n    value: function prepareTileSets() {\n      var _this3 = this;\n\n      this.tilesets = {};\n      this.map.tilesets.forEach(function (tileSet, index) {\n        var tileSetContent = _this3.levelData.map.tilesets[index];\n\n        var mapTileset = _this3.map.addTilesetImage(tileSet.name, tileSetContent);\n\n        _this3.tilesets[tileSetContent] = mapTileset;\n      }, this);\n    }\n  }, {\n    key: \"setPrefabs\",\n    value: function setPrefabs() {\n      this.prefabsClasses = {\n        player: Player.prototype.constructor,\n        door: Door.prototype.constructor,\n        npc: NPC.prototype.constructor\n      };\n    } //#endregion\n\n  }]);\n\n  return WorldScene;\n}(JSonLevelScene);\n\nexport default WorldScene;"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AClFA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AChCA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AChGA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC5DA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AChDA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AClEA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACjEA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACxMA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC1EA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACpIA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC/GA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC9DA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;A","sourceRoot":""}